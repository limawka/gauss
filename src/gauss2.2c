#include <stdlib.h>
#include <math.h>

#include "gauss.h"

/**
 * Zwraca 0 - elimnacja zakonczona sukcesem
 * Zwraca 1 - macierz osobliwa - dzielenie przez 0
 * Zwraca 2 - zly rozmiar macierzy
 */
void expandMatrix(Matrix *mat, Matrix *b){
	int i;
	(mat->c)++;
	for(i = 0; i < mat->r; i++){
		mat->data[i] = (double*) realloc(mat->data[i], sizeof(double) * mat->c);
		mat->data[i][mat->c-1] = b->data[i][0];
	}
}

int eliminate(Matrix *mat, Matrix *b, Matrix* q){
    /**
  	 * Tutaj należy umieścić właściwą implemntację.
	*/
	double m;
	int i, j, k;
	double max=0, t;
	int max_r;
	double* tp;
	if(mat->r != mat->c) return 2;

	expandMatrix(mat, b);	// rozszerzamy macierz A o b

	printToScreen(mat);

	int n = mat->r;

	for(i = 0; i < n; i++){
		// szukanie elementu diagonalnego
		for(j = i; j < n; j++){
			if(fabs(mat->data[j][i]) > max){
				max = fabs(mat->data[j][i]);
				max_r = j;
			}
		}
		// jezeli nie ma elementu innego niz 0, bedzie on na przekatnej - macierz osobliwa
		if(max==0) return 1;

		tp=mat->data[i];

		// zamiana wierszy
		if(i != max_r){
			mat->data[i] = mat->data[max_r];
			mat->data[max_r] = tp;
		}

		// eliminacja gaussa
		for( j = i+1; j < n; j++ )
		{
			m = mat->data [ j ][ i ] / mat->data [ i ][ i ];
			for( k = i ; k <= n; k++ )
				mat->data [ j ][ k ] -= m * mat->data [ i ][ k ];
		}
		max = 0;
	}

	if( mat->data[n-1][n-1] == 0 ) 
		return 1;

	//printToScreen(mat);

	return 0;
}

